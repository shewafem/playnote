import { NextResponse } from "next/server";
import { RegisterSchema } from "@/schemas/auth-schema";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs"

export async function POST(request: Request) {
	try {
		// 1. Парсинг и валидация входных данных (OWASP A03:2021 – Injection)
		// Крайне важно валидировать все входящие данные для предотвращения инъекций и обеспечения целостности данных.
		const body = await request.json();
		const validatedFields = RegisterSchema.safeParse(body);

		// Если валидация не прошла, возвращаем ошибку 400 Bad Request.
		// Избегайте слишком подробных сообщений об ошибках, которые могут раскрыть внутреннюю структуру.
		if (!validatedFields.success) {
			// Для отладки на сервере можно логировать детальные ошибки валидации:
			// console.warn("REGISTRATION_VALIDATION_FAILED", validatedFields.error.flatten());
			return NextResponse.json({ error: "Невалидные данные" }, { status: 400 });
		}

		const { email, password } = validatedFields.data;

		// 2. Проверка на существование пользователя (OWASP A04:2021 – Insecure Design - User/Email Enumeration)
		// Предотвращение создания дублирующихся аккаунтов и информирование пользователя.
		// Нормализуем email (приводим к нижнему регистру), чтобы избежать дубликатов из-за разного регистра.
		const normalizedEmail = email.toLowerCase();
		const existingUser = await prisma.user.findUnique({
			where: { email: normalizedEmail },
		});

		if (existingUser) {
			// Возврат специфического сообщения "email уже используется" - это компромисс с точки зрения UX.
			// Это подтверждает, что email существует. Для приложений с очень высокими требованиями к безопасности
			// может быть предпочтительнее общее сообщение об ошибке.
			// КРИТИЧЕСКИ ВАЖНО: Внедрите ограничение частоты запросов (rate limiting) для предотвращения
			// злоупотребления этим эндпоинтом для перебора email-адресов.
			return NextResponse.json(
				{ error: "Аккаунт с таким адресом электронной почты уже существует." },
				{ status: 409 } // 409 Conflict
			);
		}

		// 3. Хэширование пароля (OWASP A02:2021 – Cryptographic Failures)
		// НИКОГДА не храните пароли в открытом виде. Используйте сильный, адаптивный, соленый алгоритм хэширования.
		// Argon2 автоматически генерирует и включает соль в результирующий хэш.
		let hashedPassword;
		try {
			// Используем Argon2 для хэширования пароля.
			hashedPassword = await bcrypt.hash(password, 10);
		} catch (hashError) {
			// Логируем ошибку хэширования на сервере.
			console.error("PASSWORD_HASHING_ERROR", hashError);
			// Возвращаем клиенту общее сообщение об ошибке.
			return NextResponse.json(
				{ error: "Не удалось обработать регистрацию. Пожалуйста, попробуйте еще раз." },
				{ status: 500 }
			);
		}

		// 4. Создание нового пользователя в базе данных
		// Сохраняем пользователя с хэшированным паролем.
		// Prisma помогает предотвратить SQL-инъекции, используя параметризованные запросы.
		await prisma.user.create({
			data: {
				email: normalizedEmail, // Сохраняем нормализованный email
				hashedPassword,
				// name, // если применимо
				// emailVerified: null, // Рассмотрите добавление потока верификации email
				// role: 'USER', // Роль по умолчанию, если применимо
			},
		});

		// 5. Возврат успешного ответа
		// Возвращаем статус 201 Created.
		// Избегайте возврата конфиденциальной информации в успешном ответе.
		// Рекомендуется сообщить пользователю о необходимости подтвердить email, если вы внедряете верификацию.
		return NextResponse.json(
			{ success: "Аккаунт успешно создан. Пожалуйста, проверьте свою почту для верификации." }, // Измените, если не используете верификацию email
			{ status: 201 }
		);
	} catch (error: unknown) {
		// Явно указываем тип error или any/unknown для последующей проверки
		// 6. Обработка общих ошибок сервера
		// Логируем фактическую ошибку на сервере для отладки.
		// (OWASP A09:2021 – Security Logging and Monitoring Failures - убедитесь в наличии должного логирования)
		if (error instanceof Error) {
			console.error("REGISTRATION_ROUTE_ERROR", {
				message: error.message,
				stack: error.stack,
				name: error.name,
			});
		} else {
			console.error("REGISTRATION_ROUTE_ERROR", { message: "Неизвестная ошибка" });
		}

		// Возвращаем клиенту общее сообщение об ошибке, чтобы избежать утечки внутренних деталей.
		// (OWASP A05:2021 – Security Misconfiguration - слишком подробные ошибки)
		return NextResponse.json({ error: "Произошла внутренняя ошибка сервера при регистрации." }, { status: 500 });
	}
}

// --- ВАЖНЫЕ АСПЕКТЫ БЕЗОПАСНОСТИ (Реализуются вне этого обработчика) ---
// 1. ОГРАНИЧЕНИЕ ЧАСТОТЫ ЗАПРОСОВ (RATE LIMITING):
//    - КРИТИЧЕСКИ ВАЖНО для предотвращения атак перебора (brute-force) на эндпоинт регистрации
//      (например, проверка существования email) и защиты от DoS-атак.
//    - Реализуйте на уровне шлюза API (API Gateway), CDN или с помощью middleware,
//      используя постоянное хранилище (например, Redis, Upstash).
//    - Ограничьте количество запросов с одного IP, для одной сессии пользователя (если применимо до входа) и т.д.
//
// 2. ВЕРИФИКАЦИЯ EMAIL:
//    - Настоятельно рекомендуется для подтверждения того, что пользователь владеет указанным адресом электронной почты.
//    - Отправляйте ссылку/код для верификации при регистрации.
//    - Помечайте аккаунты как непроверенные до момента подтверждения.
//
// 3. САНИТИЗАЦИЯ ВВОДА (помимо валидации):
//    - Хотя Zod валидирует структуру и типы, убедитесь, что любые данные, напрямую отображаемые в HTML
//      (например, в админ-панели), должным образом экранируются для предотвращения XSS-атак.
//
// 4. HTTPS:
//    - Убедитесь, что все ваше приложение обслуживается по HTTPS в production-среде.
//
// 5. УПРАВЛЕНИЕ ЗАВИСИМОСТЯМИ:
//    - Регулярно обновляйте зависимости (`npm audit`, `yarn audit`) для исправления известных уязвимостей.
//
// 6. ПОЛИТИКИ ПАРОЛЕЙ:
//    - Внедряйте строгие политики паролей (длина, сложность) через вашу Zod-схему (`RegisterSchema`).
//    - Рассмотрите интеграцию с сервисами типа "Have I Been Pwned?" для проверки, не фигурировал ли
//      выбранный пароль в известных утечках (делайте это безопасно, например, через k-anonymity API).
